module Database; 
import * from ABS.DC;

//************** For the accounting of the usage of resources**********************
type MachineUseLog =  Map<DeploymentComponent,Pair<Time,Maybe<Time>>>;


def Rat calcCost( MachineUseLog ml, Int cost, Int interval, Time now) =
     case ml{
       InsertAssoc(Pair(id, Pair(s,e)), mlt) => (costMachine(s,e,now)/interval)*cost + calcCost(mlt, cost, interval,now);
	 EmptyMap => 0;
       };

def Rat costMachine(Time start ,Maybe<Time> end ,Time now) =
case end {
  Nothing => timeDifference(start, now);
  Just(e) => timeDifference(start, e);
};

def Map<A, B> mapTail<A, B>(Map<A, B> map) = // remove the head of the map
  case map {
  	EmptyMap => map;
    InsertAssoc(pair, tail) => tail;
  };

  def Pair<A, B> mapHead<A, B>(Map<A, B> map, Pair<A,B> default) = // remove the tail of the map
  case map {
    EmptyMap => default;
    InsertAssoc(Pair(one,two), tail) => Pair(one,two);
  };

 // *************************************************************************************

 // The clients
interface Client {}

// Client with asynchronous calls (i.e., floods the system)
class OpenClient (SE ep, Int cycle, Rat cost, Int nbrOfJobs, Counter c) implements Client {
    Int jobcount = 0;
    Unit run() { 
        Fut<Bool> fresult =  ep!invokeService(cost);
        jobcount = jobcount + 1;
        await duration(cycle, cycle);
        if (jobcount < nbrOfJobs) { this!run(); }
        await fresult?; 
        Bool result = fresult.get;
        if (result == True)  {await c!addSuccesses(1);} else {await c!addFails(1);}
    }
}

// Abstraction of the backend system
interface Service {
    Bool register(Duration deadline, Time calltime, Int customerId);
}

class Service(Int registerCost) implements Service {
    Bool register(Duration deadline, Time calltime, Int customerId) {
        println("[Registering customer: " + toString(customerId) + ", time: " +toString(timeValue(now()))+"] Service processing job, available time is "+toString(deadline));
        Int cost = registerCost;
            
        while (cost > 0) {
            [Cost: 1 ] cost = cost -1; suspend;}
            Rat remainingTime = timeDifference(calltime,now());
            println("[Time: "+toString(timeValue(now()))+"] Registered the customer " + toString(customerId));
            if ((durationValue(deadline) - remainingTime) > 0){
                println("[Time: "+toString(timeValue(now()))+"] The registration succeeded on time! [customer: " + toString(customerId) + "]");
            } else {
                println("[Time: "+toString(timeValue(now()))+"] The registration violated deadline! [customer: " + toString(customerId) + "]");
        }    
        return (durationValue(deadline) - remainingTime) > 0;
    }
}

interface Worker {
    Bool process(Rat taskCost,  Time started, Duration deadline);
    DC getDC();
}

class Worker(Service service, Int id) implements Worker {
  Bool process(Rat taskCost, Time started, Duration deadline) {
    println("[Time: "+toString(timeValue(now()))+"] Worker " + toString(this.id) + " has started processing a job");
    [Cost: taskCost] skip;                                  
    Duration remainingTime = subtractFromDuration(deadline, timeDifference(started,now()));
    // When we receive more jobs, this becomes a bottleneck
    Bool success = await service!register(remainingTime, now(), random(1000000)); 
    return success;
  }
  
  DC getDC(){ return thisDC();}
}

/*
Class to specify LoadBalancer
The LoadBalancer will decide which worker gets the next job
*/
interface LoadBalancer {
    Worker getWorker();
    Unit releaseWorker(Worker w);
    Unit addWorker(Worker w);
    Worker firingWorker();
    Int getNbrAvailableW();
    Int getNbrInuseW();
    
    Bool getFinished();
    Unit setFinished(Bool finished);
    Unit setClientsStarted(Bool started);
  }
  
class RoundRobinLoadBalancer(Counter counter, Int jobCount) implements LoadBalancer {
    List<Worker> available = Nil;
    List<Worker> inuse = Nil;
    Bool finished = False;
    Bool clientsStarted = False;

    Bool getFinished() {
        return this.finished;
    }

    Unit setFinished(Bool finished) {
        this.finished = finished;
    }

    Unit setClientsStarted(Bool started) {
        this.clientsStarted = started;
    }
  
    Unit run() {
        Int inUseCount = await this!getNbrInuseW();
        while (this.clientsStarted == False) {
            await duration(2,2);
        }
        await duration(1, 1);
        // println("Running workers: " + toString(inUseCount) + ", finished: " + toString(this.finished));
        Int finishedJobs = await this.counter!getFinished();
        // println("Finished: " + toString(finishedJobs) + ", jobCount: " + toString(jobCount));

        if (this.finished == False && finishedJobs >= jobCount) {
            this.setFinished(True);
            println("\n*********************************** Finished running ***********************************");
            await this.counter!printSuccess();
            await this.counter!printFail();
            // await this.counter!calculateCost(50,1,now());
            // await this.counter!printMachineUseLog();
        }

        if (this.finished == False) {
            this!run();
        }
      }
    
      Worker getWorker(){
      await (available != Nil);
      Worker w = head(available);
      available = tail(available);
      inuse = appendright(inuse,w); 
      return w;
        }
  
      Unit releaseWorker(Worker w){
        available = appendright(available,w);
        inuse = without(inuse,w); 
    }
  
      Unit addWorker(Worker w){
      available = appendright(available,w);
        }
  
      Worker firingWorker(){
         await (available != Nil);
         Worker w = head(reverse(available));
         available =  without(available,w);
         return w;
       }
  
       Int getNbrAvailableW() {
         Int a =length(available);     
         return a;}
       
      Int getNbrInuseW() {
        Int i = length(inuse);
        return i;
      }
  }

  interface Autoscaler {}


class Autoscaler(CloudProvider cloud, LoadBalancer lb, Int nbrOfWorkers, Int maxWorkers, Int nResources, Int cycle, Int taskCost, Counter c)
implements Autoscaler {
  Unit run(){
    [Cost: 1] skip;
    Int ctr = 0;
    while (ctr < nbrOfWorkers) {
        Fut<DC> fs =  cloud!launchInstance(map[Pair(Speed, nResources)]);
        DC vm = fs.get;
        [DC: vm] Service service = new Service(taskCost);
        [DC: vm] Worker w = new Worker(service, ctr + 1);
        lb!addWorker(w);
        Time startTime = await vm!getCreationTime();
        await c!addMachine(vm,startTime);
        ctr=ctr+1;
      }
      println("[Time: "+toString(timeValue(now()))+"] ***********INIT: CREATED "+toString(nbrOfWorkers)+" WORKERS");
      this!resize();
    }
    
    Unit resize() {
        [Cost: 2] skip;
        Int ctr = 0;
        await duration(cycle, cycle);
        Int available = await lb!getNbrAvailableW();
        Int inuse = await lb!getNbrInuseW();

        println("========== [AUTOSCALE STATUS] Available: " + toString(available) + ", inuse: " + toString(inuse) + ", max: " + toString(maxWorkers));
      
        if (available < ((available+inuse)/4) && (available+inuse)<=maxWorkers/2) {
            ctr = 0;
            Rat extraworkers= inuse;
            while (ctr<extraworkers ) {
                Fut<DC> fs =  cloud!launchInstance(map[Pair(Speed, nResources)]);
                DC vm = fs.get;
                [DC: vm] Service service = new Service(taskCost);
                [DC: vm] Worker w = new Worker(service, ctr + 1);
                await lb!addWorker(w);
                Time startTime = await vm!getCreationTime();
                await c!addMachine(vm,startTime);
                ctr=ctr+1;
            }
        }

        if ((inuse/3 < available) && (available > nbrOfWorkers)) {
	        ctr = 0;
	        Rat removeworkers= available/2;
            while (ctr<removeworkers) {
                Worker w = await lb!firingWorker();
                DC dc = await w!getDC();
                    Bool down = await cloud!shutdownInstance(dc);
                await  c!addShutdown(dc, now());
                ctr=ctr+1;
            }
        }

        Bool lbFinished = await lb!getFinished();
        if (lbFinished != True) {
            this!resize();     
        }
    }
 }

  
  // Class to specify Application API
interface SE { 
    Bool invokeService(Rat cost);
}
class ServiceEndpoint(LoadBalancer lb, Duration responseTime) implements SE {

    Bool invokeService(Rat cost){
      Time started = now();
      [Cost: 1] skip;
      Worker w =  await lb!getWorker();
      Bool success = await w!process(cost,started,responseTime);
      await lb!releaseWorker(w);
      // Returns success-handler to client:
      return success;
    }

  }


  //**************** This is an object for accounting things in the model****************

interface Counter {
    Int getFinished();

    Unit addSuccesses(Int amount);
    Unit addFails(Int amount);
    Unit addMachine(DeploymentComponent id, Time startup);
    Unit addShutdown(DeploymentComponent id, Time shutdown);
    Unit printSuccess();
    Unit printFail();
    Unit calculateCost(Int cost, Int interval,Time until);
    Unit printMachineUseLog();
  
  }
  
  class Counter() implements Counter {
    Int success = 0;
    Int fail = 0;
    Int cost = 0;
  
    MachineUseLog machines = EmptyMap;

    Int getFinished() {
        return success + fail;
    }
    
    Unit addSuccesses(Int amount) {success = success+amount;}
  
    Unit addFails(Int amount){fail = fail+amount;}
  
    Unit printSuccess(){println("[Time: "+toString(timeValue(now()))+"] Total successes: "+ toString(success));}
    Unit printFail(){println("[Time: "+toString(timeValue(now()))+"] Total Fails: "+ toString(fail));}
  
    Unit addMachine(DeploymentComponent id, Time startup){
      machines =  InsertAssoc(Pair(id,Pair(startup,Nothing)), machines);
    }
    Unit addShutdown(DeploymentComponent id, Time shutdown){
      Pair<Time,Maybe<Time>> tmp = lookupDefault(machines, id,Pair(Time(-1),Nothing));
      
      machines = InsertAssoc(Pair(id, Pair(fst(tmp),Just(shutdown))), removeKey(machines, id));
    }
  
    Unit calculateCost(Int cost, Int interval,Time until){
      Rat calculatedCost = calcCost(machines, cost, interval, until);
      println("[Time: "+toString(timeValue(now()))+"] Total Cost on the cloud (until time " +toString(timeValue(now()))+ "):"+ toString(calculatedCost));
    }
  
    Unit printMachineUseLog(){
        MachineUseLog tmp =  machines;
        DeploymentComponent tdc = null;
        while (tmp != EmptyMap) {	
      Pair<DeploymentComponent,Pair<Time,Maybe<Time>>> head = mapHead(tmp,Pair(tdc,Pair(Time(-1),Nothing)));
      DeploymentComponent dc = fst(head);
      String name = await dc!getName();
      Pair<Time,Maybe<Time>> tmptime = snd(head);
      Time frmt = fst(tmptime);
      Maybe<Time> tot = snd(tmptime);
  
       if  (tot != Nothing){
         println("[Time: "+toString(timeValue(now()))+"]"+name+"->("+toString(timeValue(frmt))+","+toString(timeValue(fromJust(tot)))+")");
       }else{
         println("[Time: "+toString(timeValue(now()))+"]"+name+"->("+toString(timeValue(frmt))+",-)");
        }
       tmp = mapTail(tmp);	
      }
        }
  
  }
   //****************************************************

// Main block
{
    //parameters
    Int workersCount = 8;
    Int maxWorkersCount = 16;
    Int clientsCount = 200;
    Int clientJobsCount = 1;
    Int taskCost = 10;
    Int workerSpeed = 40;
    Int autoScaleInterval = 2;
    Duration deadline = Duration(10);

    // Create the cloud provider
    CloudProvider cloud = new CloudProvider("cloud");
    println("[Time: "+toString(timeValue(now()))+"] Created the CloudProvider");

    // Create server machines
    DC frontendServer = await cloud!launchInstance(map[Pair(Speed, 1000)]);

    // Deploy the system
    Counter counter = new Counter();
    [DC: frontendServer] LoadBalancer lb = new RoundRobinLoadBalancer(counter, clientsCount * clientJobsCount);
    [DC: frontendServer] Autoscaler autoScaler = new Autoscaler(cloud, lb, workersCount, maxWorkersCount, workerSpeed, autoScaleInterval, taskCost, counter);
    [DC: frontendServer] SE endpoint = new ServiceEndpoint(lb, deadline);

    // Start up clients
    Int runningClientsCount = clientsCount;
    while (runningClientsCount > 0) {
        new OpenClient(endpoint, 1, taskCost, clientJobsCount, counter);
        runningClientsCount = runningClientsCount - 1;
    }
    lb.setClientsStarted(True);

    println("[Time: "+toString(timeValue(now()))+"] ******CREATED " +toString(clientsCount)+"  OPEN CLIENTS  WITH "  +toString(clientJobsCount)+ " JOBS EACH");
}
